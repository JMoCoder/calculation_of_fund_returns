# 收益分配测算系统 - 技术架构设计

## 1. 架构概述

### 1.1 架构原则
- **分层架构**: 清晰的分层设计，便于维护和扩展
- **前后端分离**: 前端负责展示，后端负责计算和数据处理
- **无状态设计**: 后端API无状态，便于水平扩展
- **安全优先**: 数据不持久化，确保用户数据安全
- **高性能**: 优化计算算法，提供快速响应

### 1.2 整体架构图

```
┌─────────────────────────────────────────────────────────┐
│                    用户界面层                            │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐      │
│  │   参数输入   │ │   结果展示   │ │   数据导出   │      │
│  └─────────────┘ └─────────────┘ └─────────────┘      │
└─────────────────────────────────────────────────────────┘
                            │
                         HTTP/HTTPS
                            │
┌─────────────────────────────────────────────────────────┐
│                    Web服务层                            │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐      │
│  │   API网关   │ │   负载均衡   │ │   静态资源   │      │
│  └─────────────┘ └─────────────┘ └─────────────┘      │
└─────────────────────────────────────────────────────────┘
                            │
                         REST API
                            │
┌─────────────────────────────────────────────────────────┐
│                   应用服务层                            │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐      │
│  │   参数验证   │ │   计算引擎   │ │   文件处理   │      │
│  └─────────────┘ └─────────────┘ └─────────────┘      │
└─────────────────────────────────────────────────────────┘
                            │
                         内存操作
                            │
┌─────────────────────────────────────────────────────────┐
│                    数据存储层                            │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐      │
│  │   Redis缓存  │ │   临时文件   │ │   会话存储   │      │
│  └─────────────┘ └─────────────┘ └─────────────┘      │
└─────────────────────────────────────────────────────────┘
```

## 2. 前端技术架构

### 2.1 技术栈选择

#### 核心技术
```json
{
  "framework": "Vanilla JavaScript (ES6+)",
  "styling": "CSS3 + Tailwind CSS",
  "build": "Webpack 5",
  "package_manager": "npm",
  "module_system": "ES Modules"
}
```

#### 主要依赖库
```json
{
  "ui_framework": "Bootstrap 5.3.0",
  "charts": "Chart.js 4.0.0",
  "tables": "DataTables 1.13.0",
  "file_processing": "SheetJS 0.19.0",
  "http_client": "Axios 1.5.0",
  "date_handling": "Day.js 1.11.0",
  "validation": "Joi 17.9.0",
  "icons": "Feather Icons 4.29.0"
}
```

### 2.2 前端架构设计

#### 目录结构
```
src/
├── assets/                 # 静态资源
│   ├── css/               # 样式文件
│   ├── js/                # JavaScript文件
│   ├── images/            # 图片资源
│   └── fonts/             # 字体文件
├── components/            # 组件
│   ├── forms/             # 表单组件
│   ├── tables/            # 表格组件
│   ├── charts/            # 图表组件
│   └── common/            # 通用组件
├── pages/                 # 页面
│   ├── input/             # 参数输入页面
│   ├── results/           # 结果展示页面
│   └── visualization/     # 可视化页面
├── services/              # 服务层
│   ├── api.js             # API调用
│   ├── calculation.js     # 前端计算
│   ├── validation.js      # 数据验证
│   └── storage.js         # 本地存储
├── utils/                 # 工具函数
│   ├── formatters.js      # 格式化工具
│   ├── validators.js      # 验证工具
│   └── helpers.js         # 辅助函数
└── main.js                # 入口文件
```

#### 模块化设计
```javascript
// 主应用类
class FundCalculatorApp {
  constructor() {
    this.router = new Router();
    this.apiService = new ApiService();
    this.storageService = new StorageService();
    this.init();
  }

  init() {
    this.setupRoutes();
    this.bindEvents();
    this.loadInitialData();
  }

  setupRoutes() {
    this.router.add('/input', () => new InputPage());
    this.router.add('/results', () => new ResultsPage());
    this.router.add('/visualization', () => new VisualizationPage());
  }
}

// 组件基类
class Component {
  constructor(element) {
    this.element = element;
    this.state = {};
    this.init();
  }

  init() {
    this.render();
    this.bindEvents();
  }

  render() {
    // 渲染逻辑
  }

  bindEvents() {
    // 事件绑定
  }

  setState(newState) {
    this.state = { ...this.state, ...newState };
    this.render();
  }
}
```

### 2.3 状态管理

#### 简单状态管理器
```javascript
class StateManager {
  constructor() {
    this.state = {
      basicParams: {},
      cashFlows: [],
      distributionMode: null,
      calculationResults: null,
      loading: false,
      errors: {}
    };
    this.listeners = [];
  }

  getState() {
    return { ...this.state };
  }

  setState(updates) {
    this.state = { ...this.state, ...updates };
    this.notifyListeners();
  }

  subscribe(listener) {
    this.listeners.push(listener);
    return () => {
      this.listeners = this.listeners.filter(l => l !== listener);
    };
  }

  notifyListeners() {
    this.listeners.forEach(listener => listener(this.state));
  }
}
```

### 2.4 API通信

#### API服务封装
```javascript
class ApiService {
  constructor() {
    this.baseURL = '/api/v1';
    this.client = axios.create({
      baseURL: this.baseURL,
      timeout: 30000,
      headers: {
        'Content-Type': 'application/json'
      }
    });
    this.setupInterceptors();
  }

  setupInterceptors() {
    // 请求拦截器
    this.client.interceptors.request.use(
      config => {
        config.headers['X-Session-ID'] = this.getSessionId();
        return config;
      },
      error => Promise.reject(error)
    );

    // 响应拦截器
    this.client.interceptors.response.use(
      response => response.data,
      error => {
        this.handleError(error);
        return Promise.reject(error);
      }
    );
  }

  // API方法
  async calculate(params) {
    return this.client.post('/calculate', params);
  }

  async uploadFile(file) {
    const formData = new FormData();
    formData.append('file', file);
    return this.client.post('/upload', formData, {
      headers: { 'Content-Type': 'multipart/form-data' }
    });
  }

  async exportResults(format = 'xlsx') {
    return this.client.get(`/export?format=${format}`, {
      responseType: 'blob'
    });
  }
}
```

## 3. 后端技术架构

### 3.1 技术栈选择

#### 核心技术
```json
{
  "language": "Python 3.9+",
  "framework": "FastAPI 0.103.0",
  "async_runtime": "asyncio",
  "validation": "Pydantic 2.0",
  "testing": "pytest 7.4.0"
}
```

#### 主要依赖库
```json
{
  "web_framework": "fastapi[all]==0.103.0",
  "data_processing": {
    "numpy": "1.24.0",
    "pandas": "2.0.0",
    "scipy": "1.11.0"
  },
  "file_processing": {
    "openpyxl": "3.1.0",
    "xlsxwriter": "3.1.0"
  },
  "caching": "redis[hiredis]==4.6.0",
  "http_client": "httpx==0.24.0",
  "logging": "structlog==23.1.0",
  "monitoring": "prometheus-client==0.17.0"
}
```

### 3.2 后端架构设计

#### 目录结构
```
app/
├── api/                   # API路由
│   ├── v1/               # API版本1
│   │   ├── endpoints/    # 端点定义
│   │   └── dependencies/ # 依赖注入
│   └── middleware/       # 中间件
├── core/                 # 核心配置
│   ├── config.py         # 配置管理
│   ├── security.py       # 安全配置
│   └── logging.py        # 日志配置
├── models/               # 数据模型
│   ├── requests/         # 请求模型
│   ├── responses/        # 响应模型
│   └── domain/           # 领域模型
├── services/             # 业务服务
│   ├── calculation/      # 计算服务
│   ├── validation/       # 验证服务
│   ├── file_processing/  # 文件处理
│   └── export/           # 导出服务
├── utils/                # 工具函数
│   ├── formatters.py     # 格式化工具
│   ├── validators.py     # 验证工具
│   └── helpers.py        # 辅助函数
├── tests/                # 测试文件
│   ├── unit/             # 单元测试
│   ├── integration/      # 集成测试
│   └── fixtures/         # 测试数据
└── main.py               # 应用入口
```

#### 应用架构
```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.gzip import GZipMiddleware

# 应用工厂
def create_app() -> FastAPI:
    app = FastAPI(
        title="收益分配测算系统",
        description="基于净现金流的投资收益测算API",
        version="1.0.0",
        docs_url="/docs",
        redoc_url="/redoc"
    )
    
    # 中间件配置
    setup_middleware(app)
    
    # 路由配置
    setup_routes(app)
    
    # 异常处理
    setup_exception_handlers(app)
    
    return app

def setup_middleware(app: FastAPI):
    # CORS中间件
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )
    
    # 压缩中间件
    app.add_middleware(GZipMiddleware, minimum_size=1000)
    
    # 自定义中间件
    app.add_middleware(SessionMiddleware)
    app.add_middleware(LoggingMiddleware)
    app.add_middleware(SecurityMiddleware)
```

### 3.3 数据模型设计

#### 请求模型
```python
from pydantic import BaseModel, Field, validator
from typing import List, Optional
from enum import Enum

class DistributionMode(str, Enum):
    FLAT_PRINCIPAL_FIRST = "flat_principal_first"
    FLAT_PERIODIC = "flat_periodic"
    STRUCTURED_SENIOR_SUBORDINATE = "structured_senior_subordinate"
    STRUCTURED_WITH_MEZZANINE = "structured_with_mezzanine"
    STRUCTURED_INTEREST_PRINCIPAL = "structured_interest_principal"

class BasicParams(BaseModel):
    investment_target: str = Field(..., min_length=1, max_length=100)
    investment_amount: float = Field(..., gt=0, le=999999)
    investment_period: int = Field(..., ge=1, le=30)
    hurdle_rate: float = Field(..., ge=0, le=100)
    carry_rate: float = Field(..., ge=0, le=100)
    
    @validator('investment_amount')
    def validate_amount(cls, v):
        return round(v, 2)

class CashFlow(BaseModel):
    year: int = Field(..., ge=1, le=30)
    amount: float = Field(...)
    
    @validator('amount')
    def validate_amount(cls, v):
        return round(v, 2)

class DistributionParams(BaseModel):
    mode: DistributionMode
    periodic_rate: Optional[float] = Field(None, ge=0, le=100)
    senior_ratio: Optional[float] = Field(None, ge=1, le=99)
    mezzanine_ratio: Optional[float] = Field(None, ge=1, le=97)
    subordinate_ratio: Optional[float] = Field(None, ge=1, le=99)
    mezzanine_rate: Optional[float] = Field(None, ge=0, le=100)
    subordinate_rate: Optional[float] = Field(None, ge=0, le=100)

class CalculationRequest(BaseModel):
    basic_params: BasicParams
    cash_flows: List[CashFlow]
    distribution_params: DistributionParams
    
    @validator('cash_flows')
    def validate_cash_flows(cls, v, values):
        if 'basic_params' in values:
            expected_years = values['basic_params'].investment_period
            if len(v) != expected_years:
                raise ValueError(f"现金流数据应包含{expected_years}年的数据")
        return v
```

#### 响应模型
```python
class CalculationResult(BaseModel):
    irr: float
    dpi: float
    cash_flow_details: List[dict]
    summary: dict
    calculation_time: float

class ApiResponse(BaseModel):
    success: bool
    data: Optional[dict] = None
    message: str = ""
    error_code: Optional[str] = None
    timestamp: str
```

### 3.4 计算引擎设计

#### 计算服务架构
```python
from abc import ABC, abstractmethod
from typing import Dict, List, Any

class CalculationEngine(ABC):
    """计算引擎抽象基类"""
    
    @abstractmethod
    def calculate(self, params: CalculationRequest) -> CalculationResult:
        pass

class FlatStructureEngine(CalculationEngine):
    """平层结构计算引擎"""
    
    def calculate(self, params: CalculationRequest) -> CalculationResult:
        if params.distribution_params.mode == DistributionMode.FLAT_PRINCIPAL_FIRST:
            return self._calculate_principal_first(params)
        elif params.distribution_params.mode == DistributionMode.FLAT_PERIODIC:
            return self._calculate_periodic(params)
    
    def _calculate_principal_first(self, params: CalculationRequest) -> CalculationResult:
        # 优先还本计算逻辑
        results = []
        remaining_principal = params.basic_params.investment_amount
        accumulated_hurdle = 0
        
        for cf in params.cash_flows:
            year_result = self._calculate_year_principal_first(
                cf.amount, remaining_principal, accumulated_hurdle, params
            )
            results.append(year_result)
            remaining_principal = year_result['remaining_principal']
            accumulated_hurdle = year_result['accumulated_hurdle']
        
        irr = self._calculate_irr(params.basic_params.investment_amount, 
                                 [cf.amount for cf in params.cash_flows])
        dpi = self._calculate_dpi(params.basic_params.investment_amount, 
                                 [cf.amount for cf in params.cash_flows])
        
        return CalculationResult(
            irr=irr,
            dpi=dpi,
            cash_flow_details=results,
            summary=self._generate_summary(results),
            calculation_time=time.time() - start_time
        )

class StructuredEngine(CalculationEngine):
    """结构化计算引擎"""
    
    def calculate(self, params: CalculationRequest) -> CalculationResult:
        mode = params.distribution_params.mode
        if mode == DistributionMode.STRUCTURED_SENIOR_SUBORDINATE:
            return self._calculate_senior_subordinate(params)
        elif mode == DistributionMode.STRUCTURED_WITH_MEZZANINE:
            return self._calculate_with_mezzanine(params)
        elif mode == DistributionMode.STRUCTURED_INTEREST_PRINCIPAL:
            return self._calculate_interest_principal(params)

class CalculationService:
    """计算服务主类"""
    
    def __init__(self):
        self.engines = {
            'flat': FlatStructureEngine(),
            'structured': StructuredEngine()
        }
    
    async def calculate(self, params: CalculationRequest) -> CalculationResult:
        # 参数验证
        await self._validate_params(params)
        
        # 选择计算引擎
        engine = self._select_engine(params.distribution_params.mode)
        
        # 执行计算
        result = engine.calculate(params)
        
        # 结果验证
        self._validate_result(result)
        
        return result
```

### 3.5 文件处理服务

#### Excel文件处理
```python
import pandas as pd
from openpyxl import Workbook
from io import BytesIO

class FileProcessingService:
    """文件处理服务"""
    
    async def parse_excel(self, file_content: bytes) -> CalculationRequest:
        """解析Excel文件"""
        try:
            # 读取Excel文件
            df = pd.read_excel(BytesIO(file_content), sheet_name=None)
            
            # 解析基本参数
            basic_params = self._parse_basic_params(df.get('基本参数', df.get('Sheet1')))
            
            # 解析现金流数据
            cash_flows = self._parse_cash_flows(df.get('现金流', df.get('Sheet2')))
            
            # 解析分配参数
            distribution_params = self._parse_distribution_params(
                df.get('分配参数', df.get('Sheet3'))
            )
            
            return CalculationRequest(
                basic_params=basic_params,
                cash_flows=cash_flows,
                distribution_params=distribution_params
            )
            
        except Exception as e:
            raise ValueError(f"Excel文件解析失败: {str(e)}")
    
    async def export_results(self, result: CalculationResult, 
                           params: CalculationRequest) -> bytes:
        """导出计算结果到Excel"""
        wb = Workbook()
        
        # 创建工作表
        self._create_summary_sheet(wb, result, params)
        self._create_details_sheet(wb, result)
        self._create_charts_sheet(wb, result)
        
        # 保存到内存
        buffer = BytesIO()
        wb.save(buffer)
        buffer.seek(0)
        
        return buffer.getvalue()
```

## 4. 数据存储架构

### 4.1 缓存设计

#### Redis配置
```python
import redis.asyncio as redis
from typing import Optional, Any
import json
import pickle

class CacheService:
    """缓存服务"""
    
    def __init__(self, redis_url: str):
        self.redis = redis.from_url(redis_url)
        self.default_ttl = 7200  # 2小时
    
    async def get(self, key: str) -> Optional[Any]:
        """获取缓存数据"""
        try:
            data = await self.redis.get(key)
            if data:
                return pickle.loads(data)
            return None
        except Exception:
            return None
    
    async def set(self, key: str, value: Any, ttl: Optional[int] = None) -> bool:
        """设置缓存数据"""
        try:
            ttl = ttl or self.default_ttl
            data = pickle.dumps(value)
            await self.redis.setex(key, ttl, data)
            return True
        except Exception:
            return False
    
    async def delete(self, key: str) -> bool:
        """删除缓存数据"""
        try:
            await self.redis.delete(key)
            return True
        except Exception:
            return False
    
    async def clear_session(self, session_id: str) -> bool:
        """清理会话数据"""
        try:
            pattern = f"session:{session_id}:*"
            keys = await self.redis.keys(pattern)
            if keys:
                await self.redis.delete(*keys)
            return True
        except Exception:
            return False
```

### 4.2 会话管理

#### 会话服务
```python
import uuid
from datetime import datetime, timedelta
from typing import Dict, Any, Optional

class SessionService:
    """会话管理服务"""
    
    def __init__(self, cache_service: CacheService):
        self.cache = cache_service
        self.session_ttl = 7200  # 2小时
    
    async def create_session(self) -> str:
        """创建新会话"""
        session_id = str(uuid.uuid4())
        session_data = {
            'id': session_id,
            'created_at': datetime.utcnow().isoformat(),
            'last_accessed': datetime.utcnow().isoformat(),
            'data': {}
        }
        
        await self.cache.set(
            f"session:{session_id}", 
            session_data, 
            self.session_ttl
        )
        
        return session_id
    
    async def get_session(self, session_id: str) -> Optional[Dict[str, Any]]:
        """获取会话数据"""
        session_data = await self.cache.get(f"session:{session_id}")
        if session_data:
            # 更新最后访问时间
            session_data['last_accessed'] = datetime.utcnow().isoformat()
            await self.cache.set(
                f"session:{session_id}", 
                session_data, 
                self.session_ttl
            )
        return session_data
    
    async def update_session(self, session_id: str, data: Dict[str, Any]) -> bool:
        """更新会话数据"""
        session_data = await self.get_session(session_id)
        if session_data:
            session_data['data'].update(data)
            session_data['last_accessed'] = datetime.utcnow().isoformat()
            return await self.cache.set(
                f"session:{session_id}", 
                session_data, 
                self.session_ttl
            )
        return False
    
    async def delete_session(self, session_id: str) -> bool:
        """删除会话"""
        return await self.cache.delete(f"session:{session_id}")
```

## 5. 安全架构

### 5.1 安全策略

#### 数据安全
```python
from cryptography.fernet import Fernet
import hashlib
import secrets

class SecurityService:
    """安全服务"""
    
    def __init__(self, secret_key: str):
        self.fernet = Fernet(secret_key.encode())
    
    def encrypt_sensitive_data(self, data: str) -> str:
        """加密敏感数据"""
        return self.fernet.encrypt(data.encode()).decode()
    
    def decrypt_sensitive_data(self, encrypted_data: str) -> str:
        """解密敏感数据"""
        return self.fernet.decrypt(encrypted_data.encode()).decode()
    
    def generate_session_token(self) -> str:
        """生成会话令牌"""
        return secrets.token_urlsafe(32)
    
    def hash_data(self, data: str) -> str:
        """数据哈希"""
        return hashlib.sha256(data.encode()).hexdigest()
    
    def validate_file_type(self, filename: str, content: bytes) -> bool:
        """验证文件类型"""
        allowed_extensions = {'.xlsx', '.xls'}
        file_ext = os.path.splitext(filename)[1].lower()
        
        if file_ext not in allowed_extensions:
            return False
        
        # 验证文件头
        if file_ext == '.xlsx':
            return content.startswith(b'PK')
        elif file_ext == '.xls':
            return content.startswith(b'\xd0\xcf\x11\xe0')
        
        return False
```

#### 输入验证
```python
import re
from typing import Any, Dict, List

class InputValidator:
    """输入验证器"""
    
    @staticmethod
    def sanitize_string(value: str) -> str:
        """字符串清理"""
        # 移除潜在的恶意字符
        value = re.sub(r'[<>"\'\/]', '', value)
        return value.strip()
    
    @staticmethod
    def validate_numeric_range(value: float, min_val: float, max_val: float) -> bool:
        """数值范围验证"""
        return min_val <= value <= max_val
    
    @staticmethod
    def validate_percentage(value: float) -> bool:
        """百分比验证"""
        return 0 <= value <= 100
    
    @staticmethod
    def validate_file_size(content: bytes, max_size: int = 10 * 1024 * 1024) -> bool:
        """文件大小验证"""
        return len(content) <= max_size
```

### 5.2 API安全

#### 中间件
```python
from fastapi import Request, HTTPException
from starlette.middleware.base import BaseHTTPMiddleware
import time

class SecurityMiddleware(BaseHTTPMiddleware):
    """安全中间件"""
    
    async def dispatch(self, request: Request, call_next):
        # 请求频率限制
        await self._rate_limit(request)
        
        # 请求大小限制
        await self._size_limit(request)
        
        # 安全头设置
        response = await call_next(request)
        self._set_security_headers(response)
        
        return response
    
    async def _rate_limit(self, request: Request):
        """请求频率限制"""
        client_ip = request.client.host
        # 实现频率限制逻辑
        pass
    
    async def _size_limit(self, request: Request):
        """请求大小限制"""
        content_length = request.headers.get('content-length')
        if content_length and int(content_length) > 50 * 1024 * 1024:  # 50MB
            raise HTTPException(status_code=413, detail="请求体过大")
    
    def _set_security_headers(self, response):
        """设置安全头"""
        response.headers['X-Content-Type-Options'] = 'nosniff'
        response.headers['X-Frame-Options'] = 'DENY'
        response.headers['X-XSS-Protection'] = '1; mode=block'
        response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'
```

## 6. 部署架构

### 6.1 容器化部署

#### Dockerfile
```dockerfile
# 前端构建阶段
FROM node:18-alpine AS frontend-builder
WORKDIR /app/frontend
COPY frontend/package*.json ./
RUN npm ci --only=production
COPY frontend/ .
RUN npm run build

# 后端运行时
FROM python:3.9-slim AS backend
WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# 安装Python依赖
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY app/ ./app/
COPY --from=frontend-builder /app/frontend/dist ./static/

# 创建非root用户
RUN useradd --create-home --shell /bin/bash app
USER app

# 暴露端口
EXPOSE 8000

# 启动命令
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

#### Docker Compose
```yaml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "8000:8000"
    environment:
      - REDIS_URL=redis://redis:6379
      - LOG_LEVEL=INFO
    depends_on:
      - redis
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    restart: unless-stopped

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - app
    restart: unless-stopped

volumes:
  redis_data:
```

### 6.2 监控和日志

#### 日志配置
```python
import structlog
import logging
from pythonjsonlogger import jsonlogger

def setup_logging():
    """配置结构化日志"""
    
    # 配置标准库日志
    logging.basicConfig(
        format="%(message)s",
        stream=sys.stdout,
        level=logging.INFO,
    )
    
    # 配置structlog
    structlog.configure(
        processors=[
            structlog.stdlib.filter_by_level,
            structlog.stdlib.add_logger_name,
            structlog.stdlib.add_log_level,
            structlog.stdlib.PositionalArgumentsFormatter(),
            structlog.processors.TimeStamper(fmt="iso"),
            structlog.processors.StackInfoRenderer(),
            structlog.processors.format_exc_info,
            structlog.processors.UnicodeDecoder(),
            structlog.processors.JSONRenderer()
        ],
        context_class=dict,
        logger_factory=structlog.stdlib.LoggerFactory(),
        wrapper_class=structlog.stdlib.BoundLogger,
        cache_logger_on_first_use=True,
    )

class LoggingMiddleware(BaseHTTPMiddleware):
    """日志中间件"""
    
    async def dispatch(self, request: Request, call_next):
        start_time = time.time()
        
        # 记录请求
        logger.info(
            "request_started",
            method=request.method,
            url=str(request.url),
            client_ip=request.client.host
        )
        
        response = await call_next(request)
        
        # 记录响应
        process_time = time.time() - start_time
        logger.info(
            "request_completed",
            method=request.method,
            url=str(request.url),
            status_code=response.status_code,
            process_time=process_time
        )
        
        return response
```

#### 性能监控
```python
from prometheus_client import Counter, Histogram, generate_latest

# 定义指标
REQUEST_COUNT = Counter(
    'http_requests_total',
    'Total HTTP requests',
    ['method', 'endpoint', 'status']
)

REQUEST_DURATION = Histogram(
    'http_request_duration_seconds',
    'HTTP request duration',
    ['method', 'endpoint']
)

CALCULATION_DURATION = Histogram(
    'calculation_duration_seconds',
    'Calculation duration',
    ['mode']
)

class MetricsMiddleware(BaseHTTPMiddleware):
    """指标收集中间件"""
    
    async def dispatch(self, request: Request, call_next):
        start_time = time.time()
        
        response = await call_next(request)
        
        # 记录指标
        REQUEST_COUNT.labels(
            method=request.method,
            endpoint=request.url.path,
            status=response.status_code
        ).inc()
        
        REQUEST_DURATION.labels(
            method=request.method,
            endpoint=request.url.path
        ).observe(time.time() - start_time)
        
        return response
```

## 7. 性能优化

### 7.1 计算优化

#### 并行计算
```python
import asyncio
from concurrent.futures import ThreadPoolExecutor
import numpy as np

class OptimizedCalculationEngine:
    """优化的计算引擎"""
    
    def __init__(self):
        self.executor = ThreadPoolExecutor(max_workers=4)
    
    async def calculate_parallel(self, scenarios: List[CalculationRequest]) -> List[CalculationResult]:
        """并行计算多个场景"""
        loop = asyncio.get_event_loop()
        
        tasks = [
            loop.run_in_executor(
                self.executor, 
                self._calculate_single, 
                scenario
            )
            for scenario in scenarios
        ]
        
        return await asyncio.gather(*tasks)
    
    def _calculate_irr_optimized(self, initial_investment: float, cash_flows: List[float]) -> float:
        """优化的IRR计算"""
        # 使用NumPy优化计算
        cf_array = np.array([-initial_investment] + cash_flows)
        
        # 牛顿法求解IRR
        rate = 0.1  # 初始猜测值
        tolerance = 1e-6
        max_iterations = 100
        
        for _ in range(max_iterations):
            periods = np.arange(len(cf_array))
            npv = np.sum(cf_array / (1 + rate) ** periods)
            
            if abs(npv) < tolerance:
                return rate
            
            # 计算导数
            dnpv = np.sum(-periods * cf_array / (1 + rate) ** (periods + 1))
            
            if abs(dnpv) < tolerance:
                break
            
            rate = rate - npv / dnpv
        
        return rate
```

### 7.2 缓存策略

#### 多级缓存
```python
class MultiLevelCache:
    """多级缓存"""
    
    def __init__(self, redis_cache: CacheService):
        self.memory_cache = {}  # 内存缓存
        self.redis_cache = redis_cache  # Redis缓存
        self.memory_ttl = 300  # 5分钟
        self.memory_max_size = 1000
    
    async def get(self, key: str) -> Optional[Any]:
        """获取缓存数据"""
        # 先查内存缓存
        if key in self.memory_cache:
            item = self.memory_cache[key]
            if time.time() < item['expires_at']:
                return item['value']
            else:
                del self.memory_cache[key]
        
        # 再查Redis缓存
        value = await self.redis_cache.get(key)
        if value is not None:
            # 写入内存缓存
            self._set_memory_cache(key, value)
            return value
        
        return None
    
    async def set(self, key: str, value: Any, ttl: Optional[int] = None) -> bool:
        """设置缓存数据"""
        # 写入Redis缓存
        await self.redis_cache.set(key, value, ttl)
        
        # 写入内存缓存
        self._set_memory_cache(key, value)
        
        return True
    
    def _set_memory_cache(self, key: str, value: Any):
        """设置内存缓存"""
        # 检查缓存大小
        if len(self.memory_cache) >= self.memory_max_size:
            # 删除最旧的项
            oldest_key = min(self.memory_cache.keys(), 
                           key=lambda k: self.memory_cache[k]['created_at'])
            del self.memory_cache[oldest_key]
        
        self.memory_cache[key] = {
            'value': value,
            'created_at': time.time(),
            'expires_at': time.time() + self.memory_ttl
        }
```

## 8. 测试策略

### 8.1 单元测试

```python
import pytest
from app.services.calculation import FlatStructureEngine
from app.models.requests import CalculationRequest, BasicParams, CashFlow, DistributionParams

class TestFlatStructureEngine:
    """平层结构计算引擎测试"""
    
    def setup_method(self):
        self.engine = FlatStructureEngine()
    
    def test_principal_first_calculation(self):
        """测试优先还本计算"""
        params = CalculationRequest(
            basic_params=BasicParams(
                investment_target="测试项目",
                investment_amount=1000.0,
                investment_period=3,
                hurdle_rate=8.0,
                carry_rate=20.0
            ),
            cash_flows=[
                CashFlow(year=1, amount=300.0),
                CashFlow(year=2, amount=400.0),
                CashFlow(year=3, amount=500.0)
            ],
            distribution_params=DistributionParams(
                mode="flat_principal_first"
            )
        )
        
        result = self.engine.calculate(params)
        
        assert result.irr > 0
        assert result.dpi > 0
        assert len(result.cash_flow_details) == 3
    
    @pytest.mark.parametrize("investment_amount,expected_dpi", [
        (1000.0, 1.2),
        (2000.0, 0.6),
        (500.0, 2.4)
    ])
    def test_dpi_calculation(self, investment_amount, expected_dpi):
        """测试DPI计算"""
        cash_flows = [400.0, 400.0, 400.0]
        dpi = self.engine._calculate_dpi(investment_amount, cash_flows)
        assert abs(dpi - expected_dpi) < 0.01
```

### 8.2 集成测试

```python
import pytest
from httpx import AsyncClient
from app.main import app

@pytest.mark.asyncio
class TestCalculationAPI:
    """计算API集成测试"""
    
    async def test_calculation_endpoint(self):
        """测试计算接口"""
        async with AsyncClient(app=app, base_url="http://test") as client:
            response = await client.post("/api/v1/calculate", json={
                "basic_params": {
                    "investment_target": "测试项目",
                    "investment_amount": 1000.0,
                    "investment_period": 3,
                    "hurdle_rate": 8.0,
                    "carry_rate": 20.0
                },
                "cash_flows": [
                    {"year": 1, "amount": 300.0},
                    {"year": 2, "amount": 400.0},
                    {"year": 3, "amount": 500.0}
                ],
                "distribution_params": {
                    "mode": "flat_principal_first"
                }
            })
            
            assert response.status_code == 200
            data = response.json()
            assert data["success"] is True
            assert "irr" in data["data"]
            assert "dpi" in data["data"]
```

## 9. 部署和运维

### 9.1 CI/CD流程

```yaml
# .github/workflows/deploy.yml
name: Deploy

on:
  push:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install -r requirements-dev.txt
      - name: Run tests
        run: |
          pytest --cov=app tests/
      - name: Run linting
        run: |
          flake8 app/
          black --check app/
  
  build:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Build Docker image
        run: |
          docker build -t fund-calculator:${{ github.sha }} .
      - name: Push to registry
        run: |
          docker push fund-calculator:${{ github.sha }}
  
  deploy:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to production
        run: |
          # 部署脚本
```

### 9.2 健康检查

```python
from fastapi import APIRouter
from app.core.config import settings

health_router = APIRouter()

@health_router.get("/health")
async def health_check():
    """健康检查接口"""
    return {
        "status": "healthy",
        "version": settings.VERSION,
        "timestamp": datetime.utcnow().isoformat()
    }

@health_router.get("/health/detailed")
async def detailed_health_check():
    """详细健康检查"""
    checks = {
        "redis": await check_redis_health(),
        "memory": check_memory_usage(),
        "disk": check_disk_usage()
    }
    
    overall_status = "healthy" if all(
        check["status"] == "healthy" for check in checks.values()
    ) else "unhealthy"
    
    return {
        "status": overall_status,
        "checks": checks,
        "timestamp": datetime.utcnow().isoformat()
    }
```

这个技术架构设计文档提供了系统的完整技术实现方案，包括前后端架构、数据存储、安全策略、部署方案等各个方面的详细设计。