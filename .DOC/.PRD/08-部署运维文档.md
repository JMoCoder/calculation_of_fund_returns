# 08-部署运维文档

## 1. 部署架构

### 1.1 部署环境

#### 开发环境
- **目标**：开发人员本地开发和调试
- **配置**：单机部署，使用Docker Compose
- **数据**：使用内存缓存，无持久化
- **监控**：基础日志输出

#### 测试环境
- **目标**：功能测试和集成测试
- **配置**：单机或小集群部署
- **数据**：Redis缓存，短期数据保留
- **监控**：完整监控和日志收集

#### 生产环境
- **目标**：正式对外服务
- **配置**：高可用集群部署
- **数据**：Redis集群，数据备份
- **监控**：全面监控、告警和日志分析

### 1.2 容器化部署

#### Docker镜像构建
```dockerfile
# 前端镜像
FROM node:18-alpine AS frontend-build
WORKDIR /app
COPY frontend/package*.json ./
RUN npm ci --only=production
COPY frontend/ .
RUN npm run build

FROM nginx:alpine
COPY --from=frontend-build /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/nginx.conf

# 后端镜像
FROM python:3.11-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY backend/ .
EXPOSE 8000
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

#### Docker Compose配置
```yaml
version: '3.8'
services:
  frontend:
    build: ./frontend
    ports:
      - "80:80"
    depends_on:
      - backend
    networks:
      - app-network

  backend:
    build: ./backend
    ports:
      - "8000:8000"
    environment:
      - REDIS_URL=redis://redis:6379
      - LOG_LEVEL=INFO
    depends_on:
      - redis
    networks:
      - app-network

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data
    networks:
      - app-network

volumes:
  redis-data:

networks:
  app-network:
    driver: bridge
```

## 2. 部署流程

### 2.1 自动化部署

#### CI/CD流水线
```yaml
# .github/workflows/deploy.yml
name: Deploy Application

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Run Tests
        run: |
          docker-compose -f docker-compose.test.yml up --build --abort-on-container-exit
          docker-compose -f docker-compose.test.yml down

  build:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Build Images
        run: |
          docker build -t fund-calc-frontend:${{ github.sha }} ./frontend
          docker build -t fund-calc-backend:${{ github.sha }} ./backend
      - name: Push Images
        run: |
          echo ${{ secrets.DOCKER_PASSWORD }} | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin
          docker push fund-calc-frontend:${{ github.sha }}
          docker push fund-calc-backend:${{ github.sha }}

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Deploy to Production
        run: |
          # 部署脚本
          ./scripts/deploy.sh ${{ github.sha }}
```

### 2.2 部署脚本

#### 部署脚本示例
```bash
#!/bin/bash
# deploy.sh

set -e

VERSION=$1
if [ -z "$VERSION" ]; then
  echo "Usage: $0 <version>"
  exit 1
fi

echo "Deploying version: $VERSION"

# 更新镜像版本
sed -i "s/image: fund-calc-frontend:.*/image: fund-calc-frontend:$VERSION/g" docker-compose.prod.yml
sed -i "s/image: fund-calc-backend:.*/image: fund-calc-backend:$VERSION/g" docker-compose.prod.yml

# 拉取新镜像
docker-compose -f docker-compose.prod.yml pull

# 滚动更新
docker-compose -f docker-compose.prod.yml up -d --no-deps backend
docker-compose -f docker-compose.prod.yml up -d --no-deps frontend

# 健康检查
echo "Waiting for services to be healthy..."
sleep 30

# 验证部署
if curl -f http://localhost/health; then
  echo "Deployment successful!"
else
  echo "Deployment failed!"
  exit 1
fi
```

## 3. 监控和日志

### 3.1 应用监控

#### 健康检查端点
```python
# 后端健康检查
@app.get("/health")
async def health_check():
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(),
        "version": os.getenv("APP_VERSION", "unknown"),
        "redis": await check_redis_connection()
    }

@app.get("/metrics")
async def metrics():
    return {
        "active_sessions": await get_active_sessions_count(),
        "memory_usage": psutil.virtual_memory().percent,
        "cpu_usage": psutil.cpu_percent(),
        "uptime": time.time() - start_time
    }
```

#### Prometheus监控配置
```yaml
# prometheus.yml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'fund-calc-backend'
    static_configs:
      - targets: ['backend:8000']
    metrics_path: '/metrics'
    scrape_interval: 30s

  - job_name: 'redis'
    static_configs:
      - targets: ['redis:6379']
```

### 3.2 日志管理

#### 日志配置
```python
# logging_config.py
import logging
import sys
from datetime import datetime

class JSONFormatter(logging.Formatter):
    def format(self, record):
        log_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "level": record.levelname,
            "message": record.getMessage(),
            "module": record.module,
            "function": record.funcName,
            "line": record.lineno
        }
        if hasattr(record, 'user_id'):
            log_entry['user_id'] = record.user_id
        if hasattr(record, 'session_id'):
            log_entry['session_id'] = record.session_id
        return json.dumps(log_entry)

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout),
        logging.FileHandler('/var/log/app.log')
    ]
)
```

#### ELK Stack集成
```yaml
# docker-compose.logging.yml
version: '3.8'
services:
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.5.0
    environment:
      - discovery.type=single-node
      - xpack.security.enabled=false
    ports:
      - "9200:9200"

  logstash:
    image: docker.elastic.co/logstash/logstash:8.5.0
    volumes:
      - ./logstash.conf:/usr/share/logstash/pipeline/logstash.conf
    ports:
      - "5044:5044"

  kibana:
    image: docker.elastic.co/kibana/kibana:8.5.0
    ports:
      - "5601:5601"
    environment:
      - ELASTICSEARCH_HOSTS=http://elasticsearch:9200
```

## 4. 备份和恢复

### 4.1 数据备份策略

#### Redis数据备份
```bash
#!/bin/bash
# backup_redis.sh

BACKUP_DIR="/backup/redis"
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="$BACKUP_DIR/redis_backup_$DATE.rdb"

# 创建备份目录
mkdir -p $BACKUP_DIR

# 执行Redis备份
docker exec redis redis-cli BGSAVE
sleep 10
docker cp redis:/data/dump.rdb $BACKUP_FILE

# 压缩备份文件
gzip $BACKUP_FILE

# 清理旧备份（保留7天）
find $BACKUP_DIR -name "*.gz" -mtime +7 -delete

echo "Backup completed: ${BACKUP_FILE}.gz"
```

#### 配置文件备份
```bash
#!/bin/bash
# backup_config.sh

CONFIG_DIR="/app/config"
BACKUP_DIR="/backup/config"
DATE=$(date +%Y%m%d_%H%M%S)

# 备份配置文件
tar -czf $BACKUP_DIR/config_backup_$DATE.tar.gz $CONFIG_DIR

# 备份Docker Compose文件
cp docker-compose.prod.yml $BACKUP_DIR/docker-compose_$DATE.yml

echo "Configuration backup completed"
```

### 4.2 灾难恢复

#### 恢复流程
```bash
#!/bin/bash
# restore.sh

BACKUP_FILE=$1
if [ -z "$BACKUP_FILE" ]; then
  echo "Usage: $0 <backup_file>"
  exit 1
fi

echo "Starting disaster recovery..."

# 停止服务
docker-compose -f docker-compose.prod.yml down

# 恢复Redis数据
if [ -f "$BACKUP_FILE" ]; then
  gunzip -c $BACKUP_FILE > /tmp/dump.rdb
  docker run --rm -v redis-data:/data -v /tmp:/backup alpine cp /backup/dump.rdb /data/
fi

# 重启服务
docker-compose -f docker-compose.prod.yml up -d

# 验证恢复
sleep 30
if curl -f http://localhost/health; then
  echo "Recovery successful!"
else
  echo "Recovery failed!"
  exit 1
fi
```

## 5. 安全配置

### 5.1 网络安全

#### 防火墙配置
```bash
# 基础防火墙规则
sudo ufw default deny incoming
sudo ufw default allow outgoing
sudo ufw allow ssh
sudo ufw allow 80/tcp
sudo ufw allow 443/tcp
sudo ufw enable
```

#### SSL/TLS配置
```nginx
# nginx SSL配置
server {
    listen 443 ssl http2;
    server_name your-domain.com;

    ssl_certificate /etc/ssl/certs/your-domain.crt;
    ssl_certificate_key /etc/ssl/private/your-domain.key;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512;
    ssl_prefer_server_ciphers off;

    location / {
        proxy_pass http://frontend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

### 5.2 访问控制

#### 限流配置
```nginx
# nginx限流
http {
    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
    limit_req_zone $binary_remote_addr zone=upload:10m rate=1r/s;

    server {
        location /api/ {
            limit_req zone=api burst=20 nodelay;
            proxy_pass http://backend;
        }

        location /upload {
            limit_req zone=upload burst=5 nodelay;
            proxy_pass http://backend;
        }
    }
}
```

## 6. 性能优化

### 6.1 缓存策略

#### Redis缓存配置
```redis
# redis.conf
maxmemory 2gb
maxmemory-policy allkeys-lru
save 900 1
save 300 10
save 60 10000
```

#### 应用层缓存
```python
# 缓存装饰器
from functools import wraps
import hashlib
import json

def cache_result(expire_time=3600):
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            # 生成缓存键
            cache_key = f"{func.__name__}:{hashlib.md5(json.dumps([args, kwargs], sort_keys=True).encode()).hexdigest()}"
            
            # 尝试从缓存获取
            cached_result = await redis_client.get(cache_key)
            if cached_result:
                return json.loads(cached_result)
            
            # 执行函数并缓存结果
            result = await func(*args, **kwargs)
            await redis_client.setex(cache_key, expire_time, json.dumps(result))
            return result
        return wrapper
    return decorator
```

### 6.2 数据库优化

#### Redis性能调优
```bash
# 系统参数优化
echo 'vm.overcommit_memory = 1' >> /etc/sysctl.conf
echo 'net.core.somaxconn = 65535' >> /etc/sysctl.conf
sysctl -p

# 禁用透明大页
echo never > /sys/kernel/mm/transparent_hugepage/enabled
```

## 7. 故障排查

### 7.1 常见问题

#### 服务无法启动
```bash
# 检查容器状态
docker-compose ps

# 查看容器日志
docker-compose logs backend
docker-compose logs frontend
docker-compose logs redis

# 检查端口占用
netstat -tulpn | grep :8000
```

#### 性能问题
```bash
# 检查系统资源
top
htop
iostat -x 1

# 检查Redis性能
docker exec redis redis-cli info stats
docker exec redis redis-cli slowlog get 10
```

### 7.2 故障处理流程

1. **问题识别**
   - 监控告警
   - 用户反馈
   - 日志分析

2. **问题定位**
   - 检查服务状态
   - 分析错误日志
   - 性能指标分析

3. **问题解决**
   - 重启服务
   - 回滚版本
   - 扩容资源

4. **问题总结**
   - 记录故障原因
   - 更新运维文档
   - 改进监控策略

## 8. 运维检查清单

### 8.1 日常检查
- [ ] 服务状态检查
- [ ] 系统资源监控
- [ ] 日志错误检查
- [ ] 备份状态确认
- [ ] 安全更新检查

### 8.2 周期性维护
- [ ] 清理旧日志文件
- [ ] 更新安全补丁
- [ ] 性能指标分析
- [ ] 备份恢复测试
- [ ] 容量规划评估

### 8.3 应急响应
- [ ] 故障响应流程
- [ ] 联系人信息更新
- [ ] 应急工具准备
- [ ] 回滚方案验证
- [ ] 通信渠道测试